<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUILTY - Daily Detective Mystery</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg-dark: #0f172a;
            --bg-medium: #1e293b;
            --bg-light: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border: #475569;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --theme-accent: #6366f1;
            --theme-gradient-start: #6366f1;
            --theme-gradient-end: #a855f7;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background */
        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.3;
            background: radial-gradient(circle at 20% 50%, var(--theme-gradient-start) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, var(--theme-gradient-end) 0%, transparent 50%),
                        radial-gradient(circle at 40% 20%, var(--theme-accent) 0%, transparent 50%);
            filter: blur(100px);
            animation: backgroundShift 20s ease-in-out infinite;
        }

        @keyframes backgroundShift {
            0%, 100% { transform: rotate(0deg) scale(1); }
            33% { transform: rotate(120deg) scale(1.1); }
            66% { transform: rotate(240deg) scale(0.9); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            position: relative;
            overflow: hidden;
            animation: fadeInDown 0.6s ease-out;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5em;
            font-weight: 800;
            background: linear-gradient(135deg, var(--theme-gradient-start), var(--theme-gradient-end));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }

        .header .subtitle {
            color: var(--text-secondary);
            font-size: 1.1em;
            position: relative;
            z-index: 1;
        }

        /* Main menu */
        .main-menu {
            max-width: 600px;
            margin: 0 auto;
            padding: 50px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .puzzle-info {
            background: var(--bg-medium);
            padding: 20px;
            border-radius: 16px;
            margin: 20px 0;
            border: 1px solid var(--border);
        }

        .puzzle-number {
            font-size: 0.9em;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .next-puzzle-timer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .timer-digit {
            background: var(--bg-light);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, var(--theme-gradient-start), var(--theme-gradient-end));
            color: white;
            border: none;
            padding: 18px 36px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Difficulty select */
        .difficulty-select {
            width: 100%;
            padding: 16px 20px;
            background: var(--bg-medium);
            border: 2px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 16px;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-select:hover {
            border-color: var(--primary);
        }

        .difficulty-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        /* Game screen */
        .game-screen {
            display: none;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Crime box */
        .crime-box {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 35px;
            border-radius: 24px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .crime-box::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 150px;
            height: 150px;
            background: var(--theme-icon);
            opacity: 0.1;
            mask-image: var(--theme-icon);
            mask-size: contain;
            mask-repeat: no-repeat;
            mask-position: center;
        }

        .crime-box h2 {
            font-size: 2em;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .crime-box p {
            font-size: 1.1em;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        /* Game stats */
        .game-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 15px 25px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 200px;
        }

        .stat-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--theme-gradient-start), var(--theme-gradient-end));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }

        .stat-content {
            flex: 1;
        }

        .stat-label {
            font-size: 0.85em;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Initial suspect */
        .initial-suspect-section {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 30px;
            border-radius: 24px;
            margin-bottom: 30px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .initial-suspect-traits {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .initial-trait {
            padding: 20px;
            border-radius: 16px;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .initial-trait::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            opacity: 0.1;
            z-index: 0;
        }

        .initial-trait > * {
            position: relative;
            z-index: 1;
        }

        .initial-trait.green {
            background: rgba(34, 197, 94, 0.15);
            border-color: var(--success);
        }

        .initial-trait.yellow {
            background: rgba(245, 158, 11, 0.15);
            border-color: var(--warning);
        }

        .initial-trait.gray {
            background: rgba(148, 163, 184, 0.15);
            border-color: var(--text-muted);
        }

        .initial-trait:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        /* Color legend */
        .color-legend {
            display: flex;
            gap: 25px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: var(--bg-medium);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .legend-item:hover {
            transform: translateY(-2px);
            background: var(--bg-light);
        }

        .color-box {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            position: relative;
        }

        .color-box::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 10px;
            background: inherit;
            opacity: 0.3;
            filter: blur(4px);
        }

        .color-box.green { background: var(--success); }
        .color-box.yellow { background: var(--warning); }
        .color-box.gray { background: var(--text-muted); }

        /* Trait guide */
        .trait-guide-section {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 30px;
            border-radius: 24px;
            margin-bottom: 30px;
            animation: slideInRight 0.6s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .trait-guide-item {
            margin: 30px 0;
        }

        .trait-guide-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .trait-spectrum {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            padding: 15px 0;
        }

        .trait-spectrum::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 10px;
            right: 10px;
            height: 4px;
            background: linear-gradient(90deg, var(--border), var(--primary), var(--border));
            border-radius: 2px;
            z-index: 0;
        }

        .trait-value {
            background: var(--bg-medium);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid var(--border);
            font-size: 0.9em;
            font-weight: 500;
            z-index: 1;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .trait-value:hover {
            transform: translateY(-4px) scale(1.05);
            border-color: var(--primary);
            background: var(--bg-light);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
        }

        .trait-arrow {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: var(--primary);
            font-weight: bold;
            opacity: 0.7;
        }

        /* Suspects grid */
        #suspectsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .suspect-card {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 25px;
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            animation: cardAppear 0.6s ease-out;
            animation-fill-mode: both;
        }

        @keyframes cardAppear {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .suspect-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent, rgba(255,255,255,0.05));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .suspect-card:hover::before {
            opacity: 1;
        }

        .suspect-card:hover:not(.disabled):not(.eliminated) {
            transform: translateY(-8px) scale(1.02);
            border-color: var(--primary);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .suspect-card.disabled {
            opacity: 0.6;
            transform: scale(0.98);
        }

        .suspect-card.eliminated {
            opacity: 0.3;
            filter: grayscale(100%) blur(1px);
            transform: scale(0.95);
        }

        .suspect-name {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .suspect-job {
            color: var(--primary);
            margin-bottom: 20px;
            font-weight: 500;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 12px;
            background: var(--bg-medium);
            border-radius: 10px;
            transition: all 0.2s ease;
        }

        .trait-item:hover {
            background: var(--bg-light);
            transform: translateX(5px);
        }

        .suspect-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .suspect-button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 0.05em;
            position: relative;
            overflow: hidden;
        }

        .suspect-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .suspect-button:hover::before {
            width: 200px;
            height: 200px;
        }

        .accuse-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .accuse-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }

        .exonerate-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }

        .exonerate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }

        /* Game board */
        .game-board {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 25px;
            border-radius: 24px;
            margin-bottom: 30px;
            min-height: 120px;
        }

        .guess-row {
            display: flex;
            gap: 25px;
            margin: 20px 0;
            padding: 20px;
            background: var(--bg-medium);
            border-radius: 16px;
            animation: guessAppear 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        @keyframes guessAppear {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .guess-row::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, var(--primary), var(--primary-dark));
            border-radius: 2px;
        }

        .guess-feedback {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            flex: 1;
        }

        .trait-feedback {
            padding: 12px 18px;
            border-radius: 12px;
            text-align: center;
            min-width: 140px;
            font-weight: 500;
            transition: all 0.3s ease;
            animation: feedbackPop 0.4s ease-out;
        }

        @keyframes feedbackPop {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .trait-feedback.correct {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
        }

        .trait-feedback.close {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .trait-feedback.wrong {
            background: var(--bg-light);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        /* Game over */
        .game-over {
            text-align: center;
            padding: 50px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            margin-top: 30px;
            animation: gameOverAppear 0.6s ease-out;
        }

        @keyframes gameOverAppear {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .game-over.won {
            border: 2px solid var(--success);
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05));
        }

        .game-over.lost {
            border: 2px solid var(--danger);
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05));
        }

        #gameOverTitle {
            font-size: 3em;
            margin-bottom: 20px;
            font-weight: 800;
        }

        .game-over.won #gameOverTitle {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-over.lost #gameOverTitle {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Developer tools */
        .dev-tools {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 25px;
            border-radius: 16px;
            z-index: 9999;
            max-width: 450px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
        }

        .dev-tools h3 {
            margin-bottom: 20px;
            color: #22c55e;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
        }

        .dev-tools button {
            background: #1e293b;
            color: #22c55e;
            border: 1px solid #22c55e;
            padding: 10px 18px;
            margin: 5px;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        .dev-tools button:hover {
            background: #22c55e;
            color: #0f172a;
            transform: translateY(-2px);
        }

        .ai-results {
            margin-top: 20px;
            padding: 20px;
            background: #0f172a;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 450px;
            overflow-y: auto;
            border: 1px solid #1e293b;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5em;
            }
            
            .container {
                padding: 15px;
            }
            
            .main-menu {
                padding: 30px 20px;
            }
            
            #suspectsGrid {
                grid-template-columns: 1fr;
            }
            
            .game-stats {
                flex-direction: column;
            }
            
            .stat-item {
                min-width: unset;
            }
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Theme-specific styling classes */
        .theme-museum {
            --theme-gradient-start: #6366f1;
            --theme-gradient-end: #a855f7;
            --theme-accent: #8b5cf6;
        }

        .theme-tech {
            --theme-gradient-start: #06b6d4;
            --theme-gradient-end: #3b82f6;
            --theme-accent: #0ea5e9;
        }

        .theme-nature {
            --theme-gradient-start: #22c55e;
            --theme-gradient-end: #10b981;
            --theme-accent: #16a34a;
        }

        .theme-space {
            --theme-gradient-start: #6366f1;
            --theme-gradient-end: #ec4899;
            --theme-accent: #a855f7;
        }

        .theme-ocean {
            --theme-gradient-start: #0891b2;
            --theme-gradient-end: #6366f1;
            --theme-accent: #0e7490;
        }

        .theme-kitchen {
            --theme-gradient-start: #f59e0b;
            --theme-gradient-end: #ef4444;
            --theme-accent: #f97316;
        }

        .theme-school {
            --theme-gradient-start: #a855f7;
            --theme-gradient-end: #ec4899;
            --theme-accent: #d946ef;
        }

        .theme-zoo {
            --theme-gradient-start: #f97316;
            --theme-gradient-end: #dc2626;
            --theme-accent: #ea580c;
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>
    
    <div class="container">
        <div class="header">
            <h1>🔍 GUILTY 🔍</h1>
            <div class="subtitle">Daily Detective Mystery</div>
        </div>

        <div id="main-menu" class="main-menu">
            <h2>Welcome, Detective</h2>
            <div class="puzzle-info">
                <div class="puzzle-number" id="puzzleNumber">Loading...</div>
                <h3 id="dailyTheme">Today's Mystery</h3>
                <p id="themeDescription">Loading theme...</p>
            </div>
            
            <select id="difficulty-select" class="difficulty-select">
                <option value="easy">Easy (8 guesses)</option>
                <option value="medium" selected>Medium (6 guesses)</option>
                <option value="hard">Hard (4 guesses)</option>
            </select>
            
            <button id="start-game" class="btn">Start Investigation</button>
            
            <div class="next-puzzle-timer">
                <span>Next puzzle in:</span>
                <span class="timer-digit" id="hours">00</span>
                <span>:</span>
                <span class="timer-digit" id="minutes">00</span>
                <span>:</span>
                <span class="timer-digit" id="seconds">00</span>
            </div>
        </div>

        <div id="game-screen" class="game-screen">
            <div class="crime-box">
                <h2 id="crimeTitle">Loading...</h2>
                <p id="crimeDescription">Loading crime details...</p>
            </div>

            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-icon">⏱️</div>
                    <div class="stat-content">
                        <div class="stat-label">Time</div>
                        <div class="stat-value" id="timerDisplay">0:00</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">🎯</div>
                    <div class="stat-content">
                        <div class="stat-label">Guesses</div>
                        <div class="stat-value" id="guessDisplay">0/6</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon">🔍</div>
                    <div class="stat-content">
                        <div class="stat-label">Viable Suspects</div>
                        <div class="stat-value" id="viableDisplay">-</div>
                    </div>
                </div>
            </div>
            
            <div id="gameBoard" class="game-board"></div>
            
            <div id="suspectsSection">
                <div id="suspectsGrid"></div>
            </div>

            <div id="gameOver" class="game-over" style="display: none;">
                <h2 id="gameOverTitle"></h2>
                <div id="gameOverMessage"></div>
                <button onclick="location.reload()" class="btn">New Game</button>
            </div>
        </div>
    </div>

    <!-- Developer Tools -->
    <div id="devTools" class="dev-tools" style="display: none;">
        <h3>Developer Tools</h3>
        <button onclick="runAIAnalysis()">Run AI Analysis (200 games)</button>
        <button onclick="showCulprit()">Show Culprit</button>
        <button onclick="runQuickTest()">Quick Test (20 games)</button>
        <button onclick="forceNewTheme()">Force New Theme</button>
        <div id="aiResults" class="ai-results"></div>
    </div>

    <script>
// GUILTY Game - Modern Edition with Daily Themes
(function() {
    'use strict';
    
    // Game state
    let gameState = {
        culprit: null,
        suspects: [],
        initialSuspect: null,
        guesses: [],
        currentGuess: 0,
        gameOver: false,
        won: false,
        difficulty: 'medium',
        startTime: null,
        timerInterval: null,
        eliminatedSuspects: new Set(),
        perfectScore: 3,
        optimalScore: 4,
        currentTheme: null,
        puzzleNumber: 0
    };

    // Daily themes configuration
    const THEMES = {
        museum: {
            name: "Museum Mystery",
            description: "A priceless artifact has vanished from the gallery!",
            icon: "🏛️",
            class: "theme-museum",
            crime: {
                title: "The Vanished Venus",
                description: "The ancient Venus statue disappeared during the gala. The thief knew the museum's blind spots perfectly."
            },
            traits: {
                access: ['Curator', 'Guard', 'VIP Guest', 'Staff', 'Tourist'],
                timing: ['Opening', 'Closing', 'Gala Night', 'Maintenance', 'Off Hours'],
                knowledge: ['Expert', 'Scholar', 'Enthusiast', 'Basic', 'None'],
                motive: ['Collector', 'Profit', 'Revenge', 'Thrill', 'Unknown'],
                behavior: ['Suspicious', 'Nervous', 'Confident', 'Normal', 'Helpful']
            },
            categories: {
                access: 'Museum Role',
                timing: 'Visit Time',
                knowledge: 'Art Knowledge',
                motive: 'Motive Type',
                behavior: 'Behavior'
            },
            suspects: {
                names: ["Dr. Chen", "Marcus Stone", "Isabella Rossi", "James Wright", "Sofia Petrov", "Ahmed Hassan", "Claire Dubois", "Viktor Kowalski", "Luna Park", "Oscar Mendez", "Aria Singh", "Felix Weber", "Naomi Tanaka", "Leo Martinez", "Emma Clarke", "Raj Patel"],
                jobs: ["Curator", "Security Chief", "Art Dealer", "Restoration Expert", "Museum Guide", "Wealthy Patron", "Janitor", "Gift Shop Manager", "Art Student", "Insurance Agent", "Archaeologist", "Museum Director", "Tourist", "Art Critic", "Photographer", "Volunteer"]
            }
        },
        tech: {
            name: "Tech Heist",
            description: "Corporate espionage rocks the tech world!",
            icon: "💻",
            class: "theme-tech",
            crime: {
                title: "The Data Breach",
                description: "Top-secret prototype plans were stolen from the server. The hacker bypassed state-of-the-art security."
            },
            traits: {
                access: ['Admin', 'Developer', 'Contractor', 'Intern', 'Visitor'],
                timing: ['Workday', 'Weekend', 'Night Shift', 'Remote', 'Holiday'],
                knowledge: ['Expert Coder', 'IT Pro', 'Tech Savvy', 'Basic User', 'Novice'],
                motive: ['Competition', 'Money', 'Revenge', 'Curiosity', 'Unknown'],
                behavior: ['Secretive', 'Stressed', 'Overconfident', 'Normal', 'Too Helpful']
            },
            categories: {
                access: 'System Access',
                timing: 'Access Time',
                knowledge: 'Tech Skills',
                motive: 'Motive',
                behavior: 'Recent Behavior'
            },
            suspects: {
                names: ["Alex Kim", "Sarah Johnson", "Miguel Rodriguez", "Priya Sharma", "Tom Anderson", "Lisa Zhang", "David Brown", "Nina Volkov", "Jack Thompson", "Maya Patel", "Chris Lee", "Emma Davis", "Ryan O'Brien", "Zoe Martin", "Kevin Wu", "Rachel Green"],
                jobs: ["Senior Developer", "Security Analyst", "Project Manager", "Intern", "IT Support", "CEO", "Data Scientist", "QA Tester", "Network Admin", "UX Designer", "Contractor", "Marketing Director", "Junior Dev", "Tech Support", "System Architect", "Consultant"]
            }
        },
        nature: {
            name: "Zoo Escape",
            description: "A rare animal has mysteriously vanished!",
            icon: "🦜",
            class: "theme-nature",
            crime: {
                title: "The Missing Macaw",
                description: "Ruby, the rare scarlet macaw, vanished from her enclosure. Someone disabled the security cameras."
            },
            traits: {
                access: ['Keeper', 'Vet', 'Manager', 'Volunteer', 'Visitor'],
                timing: ['Dawn', 'Morning', 'Afternoon', 'Evening', 'Night'],
                knowledge: ['Expert', 'Experienced', 'Trained', 'Basic', 'None'],
                motive: ['Collector', 'Black Market', 'Activism', 'Personal', 'Unknown'],
                behavior: ['Agitated', 'Secretive', 'Overly Calm', 'Normal', 'Defensive']
            },
            categories: {
                access: 'Zoo Access',
                timing: 'Last Seen',
                knowledge: 'Animal Knowledge',
                motive: 'Suspected Motive',
                behavior: 'Behavior'
            },
            suspects: {
                names: ["Dr. Wild", "Maria Santos", "Ben Cooper", "Yuki Tanaka", "Carlos Mendez", "Sophie Chen", "Mark Wilson", "Fatima Al-Rashid", "Jake Palmer", "Lily Chang", "Diego Rivera", "Anna Kowalski", "Sam Taylor", "Rosa Martinez", "Neil Patel", "Grace Kim"],
                jobs: ["Head Keeper", "Veterinarian", "Zoo Director", "Bird Specialist", "Night Guard", "Gift Shop Staff", "Volunteer", "Maintenance", "Tour Guide", "Research Student", "Photographer", "Cafe Manager", "Ticket Seller", "Exotic Pet Dealer", "Conservation Officer", "Cleaning Staff"]
            }
        },
        space: {
            name: "Space Station",
            description: "A critical component is missing from the ISS!",
            icon: "🚀",
            class: "theme-space",
            crime: {
                title: "The Missing Module",
                description: "A vital research module disappeared from the space station. All crew members are suspects."
            },
            traits: {
                access: ['Commander', 'Engineer', 'Scientist', 'Pilot', 'Specialist'],
                timing: ['Alpha Shift', 'Beta Shift', 'Gamma Shift', 'Sleep Period', 'EVA Time'],
                knowledge: ['Expert', 'Advanced', 'Trained', 'Basic', 'Limited'],
                motive: ['Sabotage', 'Espionage', 'Personal', 'Accident', 'Unknown'],
                behavior: ['Anxious', 'Evasive', 'Too Calm', 'Normal', 'Accusatory']
            },
            categories: {
                access: 'Station Role',
                timing: 'Shift Time',
                knowledge: 'Tech Level',
                motive: 'Possible Motive',
                behavior: 'Crew Behavior'
            },
            suspects: {
                names: ["Cdr. Hayes", "Dr. Petrova", "Lt. Chen", "Dr. Singh", "Eng. Martinez", "Sci. Nakamura", "Plt. Johnson", "Spc. Kowalski", "Dr. Anderson", "Eng. Kim", "Med. Santos", "Tech. Brown", "Sci. Dubois", "Plt. O'Neill", "Cdr. Volkov", "Spc. Wright"],
                jobs: ["Mission Commander", "Lead Engineer", "Research Scientist", "Pilot", "Medical Officer", "Systems Specialist", "Payload Specialist", "Flight Engineer", "Botanist", "Physicist", "Communications", "Life Support Tech", "Materials Scientist", "Navigation Officer", "Deputy Commander", "EVA Specialist"]
            }
        },
        ocean: {
            name: "Aquarium Mystery",
            description: "A rare pearl has vanished from the depths!",
            icon: "🐠",
            class: "theme-ocean",
            crime: {
                title: "The Pearl of Poseidon",
                description: "The legendary black pearl disappeared from the main tank. The thief knew the feeding schedule."
            },
            traits: {
                access: ['Diver', 'Marine Biologist', 'Manager', 'Maintenance', 'Guest'],
                timing: ['Opening', 'Feeding Time', 'Show Time', 'Closing', 'After Hours'],
                knowledge: ['Expert Diver', 'Marine Pro', 'Experienced', 'Amateur', 'None'],
                motive: ['Greed', 'Collection', 'Revenge', 'Dare', 'Unknown'],
                behavior: ['Wet Clothes', 'Nervous', 'Too Interested', 'Normal', 'Avoiding Area']
            },
            categories: {
                access: 'Aquarium Access',
                timing: 'Present When',
                knowledge: 'Diving Skills',
                motive: 'Motive',
                behavior: 'Suspicious Signs'
            },
            suspects: {
                names: ["Captain Blue", "Marina Wells", "Kai Nakamura", "Coral Smith", "Jacques Dubois", "Sandy Beach", "Neptune Jones", "Aqua Chen", "Finn MacLeod", "Pearl Garcia", "Wade Wilson", "Ariel Petrova", "Splash Taylor", "Reef Anderson", "Ocean Park", "Tide Williams"],
                jobs: ["Head Diver", "Marine Biologist", "Aquarium Director", "Tank Cleaner", "Tour Guide", "Gift Shop Owner", "Maintenance Chief", "Dolphin Trainer", "Security Guard", "Cafe Manager", "Volunteer Diver", "Research Student", "Photographer", "VIP Guest", "Night Watchman", "Feeding Specialist"]
            }
        },
        kitchen: {
            name: "Kitchen Caper",
            description: "The secret recipe has been stolen!",
            icon: "👨‍🍳",
            class: "theme-kitchen",
            crime: {
                title: "The Secret Sauce",
                description: "Chef's legendary sauce recipe vanished from the safe. Only staff knew the combination."
            },
            traits: {
                access: ['Head Chef', 'Sous Chef', 'Line Cook', 'Server', 'Guest'],
                timing: ['Prep Time', 'Lunch Rush', 'Dinner Service', 'Closing', 'After Hours'],
                knowledge: ['Master Chef', 'Experienced', 'Skilled', 'Amateur', 'None'],
                motive: ['Competition', 'Money', 'Revenge', 'Fame', 'Unknown'],
                behavior: ['Burns/Cuts', 'Distracted', 'Too Eager', 'Normal', 'Avoiding Kitchen']
            },
            categories: {
                access: 'Kitchen Access',
                timing: 'Shift Time',
                knowledge: 'Cooking Level',
                motive: 'Motive',
                behavior: 'Recent Signs'
            },
            suspects: {
                names: ["Chef Romano", "Julia Spice", "Gordon Blue", "Pepper Mills", "Basil Green", "Ginger Snap", "Salt Winters", "Olive Branch", "Sage Wisdom", "Rosemary Hill", "Thyme Lord", "Sugar Kane", "Vinny Gar", "Honey Sweet", "Chili Pepper", "Saffron Gold"],
                jobs: ["Executive Chef", "Sous Chef", "Pastry Chef", "Line Cook", "Prep Cook", "Restaurant Manager", "Head Waiter", "Sommelier", "Dishwasher", "Food Critic", "Kitchen Porter", "Bartender", "Host", "Regular Customer", "Delivery Driver", "Health Inspector"]
            }
        },
        school: {
            name: "School Mystery",
            description: "The trophy has disappeared before the big game!",
            icon: "🏫",
            class: "theme-school",
            crime: {
                title: "The Missing Trophy",
                description: "The championship trophy vanished from the display case. Someone had a key."
            },
            traits: {
                access: ['Principal', 'Teacher', 'Coach', 'Student', 'Visitor'],
                timing: ['Morning', 'Classes', 'Lunch', 'After School', 'Evening'],
                knowledge: ['Full Access', 'Staff Access', 'Limited', 'Student', 'None'],
                motive: ['Rivalry', 'Prank', 'Revenge', 'Dare', 'Unknown'],
                behavior: ['Guilty Look', 'Nervous', 'Too Helpful', 'Normal', 'Absent']
            },
            categories: {
                access: 'School Role',
                timing: 'Time Period',
                knowledge: 'Access Level',
                motive: 'Motive',
                behavior: 'Behavior'
            },
            suspects: {
                names: ["Principal Hart", "Coach Wilson", "Ms. Johnson", "Tyler Brooks", "Ashley Chen", "Mr. Peterson", "Jamie Rodriguez", "Sam Taylor", "Morgan Lee", "Casey Jones", "Jordan Smith", "Alex Brown", "Riley Davis", "Drew Martinez", "Quinn Murphy", "Blake Anderson"],
                jobs: ["Principal", "Vice Principal", "Math Teacher", "Science Teacher", "PE Coach", "Janitor", "Team Captain", "Class President", "Drama Student", "Band Member", "Debate Team", "Security Guard", "Cafeteria Staff", "School Rival", "Parent Volunteer", "Substitute Teacher"]
            }
        },
        zoo: {
            name: "Zoo Mystery",
            description: "The baby panda's favorite toy is missing!",
            icon: "🐼",
            class: "theme-zoo",
            crime: {
                title: "Bamboo Bear's Ball",
                description: "Baby panda Mei-Mei's special enrichment ball vanished. It's worth thousands to collectors."
            },
            traits: {
                access: ['Keeper', 'Vet', 'Staff', 'Volunteer', 'Visitor'],
                timing: ['Dawn', 'Morning Feed', 'Midday', 'Evening Feed', 'Night'],
                knowledge: ['Expert', 'Experienced', 'Trained', 'Basic', 'None'],
                motive: ['Money', 'Collection', 'Mistake', 'Prank', 'Unknown'],
                behavior: ['Scratches', 'Avoiding Pandas', 'Too Interested', 'Normal', 'Nervous']
            },
            categories: {
                access: 'Zoo Role',
                timing: 'Last at Enclosure',
                knowledge: 'Animal Experience',
                motive: 'Motive',
                behavior: 'Suspicious Signs'
            },
            suspects: {
                names: ["Dr. Bamboo", "Keeper Kim", "Vet Singh", "Guide Garcia", "Manager Morris", "Student Lee", "Photographer Pike", "Janitor Jones", "Donor Davis", "Researcher Reed", "Volunteer Vega", "Chef Chang", "Guard Green", "Intern Ito", "Director Drake", "Visitor Vale"],
                jobs: ["Panda Keeper", "Head Veterinarian", "Tour Guide", "Zoo Manager", "Research Student", "Wildlife Photographer", "Maintenance Staff", "Major Donor", "Conservation Scientist", "Gift Shop Staff", "Volunteer", "Zoo Cafe Chef", "Security Officer", "Summer Intern", "Zoo Director", "Annual Pass Holder"]
            }
        }
    };

    // Get current theme based on time
    function getCurrentTheme() {
        const now = new Date();
        const seed = Math.floor(now.getTime() / (12 * 60 * 60 * 1000)); // Changes every 12 hours
        const themeKeys = Object.keys(THEMES);
        const themeIndex = seed % themeKeys.length;
        return THEMES[themeKeys[themeIndex]];
    }

    // Get puzzle number
    function getPuzzleNumber() {
        const startDate = new Date('2024-01-01T00:00:00');
        const now = new Date();
        const diff = now.getTime() - startDate.getTime();
        return Math.floor(diff / (12 * 60 * 60 * 1000)) + 1;
    }

    // Update countdown timer
    function updateCountdown() {
        const now = new Date();
        const hours = now.getHours();
        let nextPuzzle;
        
        if (hours < 12) {
            nextPuzzle = new Date(now);
            nextPuzzle.setHours(12, 0, 0, 0);
        } else {
            nextPuzzle = new Date(now);
            nextPuzzle.setDate(nextPuzzle.getDate() + 1);
            nextPuzzle.setHours(0, 0, 0, 0);
        }
        
        const diff = nextPuzzle - now;
        const hoursLeft = Math.floor(diff / (1000 * 60 * 60));
        const minutesLeft = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const secondsLeft = Math.floor((diff % (1000 * 60)) / 1000);
        
        document.getElementById('hours').textContent = hoursLeft.toString().padStart(2, '0');
        document.getElementById('minutes').textContent = minutesLeft.toString().padStart(2, '0');
        document.getElementById('seconds').textContent = secondsLeft.toString().padStart(2, '0');
    }

    // Apply theme to UI
    function applyTheme(theme) {
        document.body.className = theme.class;
        gameState.currentTheme = theme;
        
        // Update main menu
        document.getElementById('puzzleNumber').textContent = `Puzzle #${getPuzzleNumber()} • ${theme.icon} ${theme.name}`;
        document.getElementById('dailyTheme').textContent = theme.icon + ' ' + theme.name;
        document.getElementById('themeDescription').textContent = theme.description;
    }

    // Game configuration (updated for themes)
    const CONFIG = {
        DIFFICULTY_SETTINGS: {
            easy: { 
                maxGuesses: 8, 
                yellowTraits: 1,      
                grayTraits: 1,        
                missingTraitsInitial: 3,
                missingTraits: 0.15,
                minViableSuspects: 8
            },
            medium: { 
                maxGuesses: 6, 
                yellowTraits: 1,      
                grayTraits: 0,        
                missingTraitsInitial: 4,
                missingTraits: 0.20,
                minViableSuspects: 10
            },
            hard: { 
                maxGuesses: 4, 
                yellowTraits: 0,      
                grayTraits: 1,        
                missingTraitsInitial: 4,
                missingTraits: 0.25,
                minViableSuspects: 12
            }
        }
    };

    // Utility functions
    function randomValue(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function getFeedback(guessValue, culpritValue, trait) {
        if (guessValue === undefined || guessValue === null) return 'unknown';
        if (culpritValue === undefined || culpritValue === null) return 'unknown';
        
        if (guessValue === culpritValue) return 'correct';
        
        const theme = gameState.currentTheme;
        const arr = theme.traits[trait];
        if (!arr) {
            console.error('getFeedback: Invalid trait', trait);
            return 'unknown';
        }
        
        const guessPos = arr.indexOf(guessValue);
        const culpritPos = arr.indexOf(culpritValue);
        
        if (guessPos === -1 || culpritPos === -1) {
            console.error('getFeedback: Value not found in trait array', { trait, guessValue, culpritValue });
            return 'wrong';
        }
        
        if (Math.abs(guessPos - culpritPos) <= 1) return 'close';
        return 'wrong';
    }

    function generateSuspects() {
        const theme = gameState.currentTheme;
        const minViable = CONFIG.DIFFICULTY_SETTINGS[gameState.difficulty].minViableSuspects;
        const missingRate = CONFIG.DIFFICULTY_SETTINGS[gameState.difficulty].missingTraits;
        let attempts = 0;
        let bestSetup = null;
        let bestViableCount = 0;
        
        while (attempts < 50) {
            attempts++;
            const suspects = [];
            
            // Generate 16 suspects with theme-appropriate names and jobs
            for (let i = 0; i < 16; i++) {
                const suspect = {
                    name: theme.suspects.names[i],
                    job: theme.suspects.jobs[i]
                };
                
                Object.keys(theme.traits).forEach(trait => {
            const initialValue = gameState.initialSuspect[trait];
            const culpritValue = gameState.culprit[trait];
            
            if (initialValue === undefined) {
                const colorClass = 'gray';
                html += '<div class="initial-trait ' + colorClass + '">';
                html += '<div><strong>' + theme.categories[trait] + '</strong></div>';
                html += '<div style="color: #999; font-style: italic;">?</div>';
                html += '</div>';
            } else {
                const feedback = getFeedback(initialValue, culpritValue, trait);
                const colorClass = feedback === 'correct' ? 'green' : 
                                 feedback === 'close' ? 'yellow' : 'gray';
                
                html += '<div class="initial-trait ' + colorClass + '">';
                html += '<div><strong>' + theme.categories[trait] + '</strong></div>';
                html += '<div>' + initialValue + '</div>';
                html += '</div>';
            }
        });
        
        html += '</div>';
        html += '<div class="color-legend">';
        html += '<span class="legend-item"><span class="color-box green"></span> Exact match</span>';
        html += '<span class="legend-item"><span class="color-box yellow"></span> Close match</span>';
        html += '<span class="legend-item"><span class="color-box gray"></span> Different</span>';
        html += '</div>';
        
        container.innerHTML = html;
        document.querySelector('.crime-box').after(container);
        
        displayTraitGuide();
    }

    function displayTraitGuide() {
        const theme = gameState.currentTheme;
        const container = document.createElement('div');
        container.className = 'trait-guide-section';
        
        let html = '<h3>Trait Value Reference</h3>';
        html += '<p style="color: var(--primary); margin-bottom: 20px;">Adjacent values (connected by lines) are considered "close" matches</p>';
        
        Object.keys(theme.traits).forEach(trait => {
            html += '<div class="trait-guide-item">';
            html += '<div class="trait-guide-title">' + theme.categories[trait] + '</div>';
            html += '<div class="trait-spectrum">';
            
            const values = theme.traits[trait];
            values.forEach((value, index) => {
                html += '<div class="trait-value">' + value + '</div>';
                
                if (index < values.length - 1) {
                    const leftPercent = (index / (values.length - 1)) * 100;
                    const rightPercent = ((index + 1) / (values.length - 1)) * 100;
                    const midPercent = (leftPercent + rightPercent) / 2;
                    html += '<span class="trait-arrow" style="left: ' + midPercent + '%">↔</span>';
                }
            });
            
            html += '</div></div>';
        });
        
        container.innerHTML = html;
        
        const initialSuspectSection = document.querySelector('.initial-suspect-section');
        if (initialSuspectSection && initialSuspectSection.nextSibling) {
            initialSuspectSection.parentNode.insertBefore(container, initialSuspectSection.nextSibling);
        } else if (initialSuspectSection) {
            initialSuspectSection.parentNode.appendChild(container);
        }
    }

    function displaySuspects() {
        const theme = gameState.currentTheme;
        const grid = document.getElementById('suspectsGrid');
        if (!grid) {
            console.error('suspectsGrid element not found');
            return;
        }
        grid.innerHTML = '';
        
        gameState.suspects.forEach((suspect, index) => {
            const card = document.createElement('div');
            card.className = 'suspect-card';
            card.style.animationDelay = (index * 0.05) + 's';
            
            if (gameState.guesses.some(g => g.name === suspect.name)) {
                card.classList.add('disabled');
            }
            if (gameState.eliminatedSuspects.has(suspect.name)) {
                card.classList.add('eliminated');
            }
            
            let traitsHTML = '';
            Object.keys(theme.traits).forEach(trait => {
                const value = suspect[trait];
                const displayValue = value !== undefined ? value : '?';
                const valueClass = value === undefined ? 'style="color: #999; font-style: italic;"' : '';
                
                traitsHTML += '<div class="trait-item">';
                traitsHTML += '<span>' + theme.categories[trait] + ':</span>';
                traitsHTML += '<span ' + valueClass + '>' + displayValue + '</span>';
                traitsHTML += '</div>';
            });
            
            let innerHTML = '<div class="suspect-name">' + suspect.name + '</div>';
            innerHTML += '<div class="suspect-job">' + suspect.job + '</div>';
            innerHTML += '<div class="suspect-traits">' + traitsHTML + '</div>';
            innerHTML += '<div class="suspect-actions">';
            innerHTML += '<button class="suspect-button accuse-btn" data-index="' + index + '">Accuse</button>';
            innerHTML += '<button class="suspect-button exonerate-btn" data-name="' + suspect.name + '">';
            innerHTML += gameState.eliminatedSuspects.has(suspect.name) ? 'Restore' : 'Exonerate';
            innerHTML += '</button></div>';
            
            card.innerHTML = innerHTML;
            grid.appendChild(card);
        });
        
        // Add event listeners after all cards are created
        document.querySelectorAll('.accuse-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                makeGuess(parseInt(this.dataset.index));
            });
        });
        
        document.querySelectorAll('.exonerate-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                toggleElimination(this.dataset.name);
            });
        });
    }

    function displayGuess(suspect) {
        const theme = gameState.currentTheme;
        const board = document.getElementById('gameBoard');
        const row = document.createElement('div');
        row.className = 'guess-row';
        
        let feedbackHTML = '<div class="guess-feedback">';
        Object.keys(theme.traits).forEach((trait, index) => {
            const feedback = getFeedback(suspect[trait], gameState.culprit[trait], trait);
            feedbackHTML += '<div class="trait-feedback ' + feedback + '" style="animation-delay: ' + (index * 0.1) + 's">';
            feedbackHTML += '<div>' + theme.categories[trait] + '</div>';
            feedbackHTML += '<div>' + suspect[trait] + '</div>';
            feedbackHTML += '</div>';
        });
        feedbackHTML += '</div>';
        
        let html = '<div><strong>' + suspect.name + '</strong><br>' + suspect.job + '</div>';
        html += feedbackHTML;
        
        row.innerHTML = html;
        board.appendChild(row);
    }

    function updateGuessCounter() {
        const max = CONFIG.DIFFICULTY_SETTINGS[gameState.difficulty].maxGuesses;
        document.getElementById('guessDisplay').textContent = gameState.currentGuess + '/' + max;
    }

    function makeGuess(index) {
        if (gameState.gameOver || index < 0 || index >= gameState.suspects.length) return;
        
        const suspect = gameState.suspects[index];
        if (gameState.guesses.some(g => g.name === suspect.name)) return;
        
        gameState.guesses.push(suspect);
        gameState.currentGuess++;
        
        displayGuess(suspect);
        updateGuessCounter();
        
        if (suspect.name === gameState.culprit.name) {
            endGame(true);
        } else if (gameState.currentGuess >= CONFIG.DIFFICULTY_SETTINGS[gameState.difficulty].maxGuesses) {
            endGame(false);
        }
        
        displaySuspects();
    }

    function toggleElimination(name) {
        if (gameState.eliminatedSuspects.has(name)) {
            gameState.eliminatedSuspects.delete(name);
        } else {
            gameState.eliminatedSuspects.add(name);
        }
        displaySuspects();
    }

    function endGame(won) {
        gameState.gameOver = true;
        gameState.won = won;
        stopTimer();
        
        const gameOverDiv = document.getElementById('gameOver');
        const title = document.getElementById('gameOverTitle');
        const message = document.getElementById('gameOverMessage');
        
        if (won) {
            gameOverDiv.className = 'game-over won';
            title.textContent = 'GUILTY!';
            
            let performanceMessage = '';
            
            if (gameState.currentGuess < gameState.perfectScore) {
                performanceMessage = '<div style="color: #ef4444; font-size: 1.3em; margin-top: 10px;">🎲 YOU GOT LUCKY! 🎲<br>Pure luck beat logic this time!</div>';
                performanceMessage += '<div style="color: var(--text-muted); margin-top: 10px;">Through logical deduction alone, this puzzle required at least ' + gameState.perfectScore + ' guesses to solve.</div>';
            } else if (gameState.currentGuess === gameState.perfectScore) {
                performanceMessage = '<div style="color: #22c55e; font-size: 1.2em; margin-top: 10px;">🏆 PERFECT DETECTIVE! 🏆<br>You achieved the optimal solution!</div>';
            } else if (gameState.currentGuess <= gameState.optimalScore) {
                performanceMessage = '<div style="color: var(--primary); font-size: 1.1em; margin-top: 10px;">⭐ Excellent deduction! Near-perfect play!</div>';
            } else if (gameState.currentGuess > gameState.perfectScore + 2) {
                const extraGuesses = gameState.currentGuess - gameState.perfectScore;
                performanceMessage = '<div style="color: #f59e0b; margin-top: 10px;">You could have solved this ' + extraGuesses + ' guess' + (extraGuesses > 1 ? 'es' : '') + ' faster with optimal play.</div>';
            }
            
            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            const timeStr = minutes + ':' + seconds.toString().padStart(2, '0');
            
            message.innerHTML = '<div style="font-size: 1.2em; margin-bottom: 20px;">You found the culprit in <strong>' + gameState.currentGuess + ' guesses</strong>!</div>';
            message.innerHTML += '<div style="color: var(--text-secondary); margin-bottom: 10px;">Time: ' + timeStr + '</div>';
            message.innerHTML += performanceMessage;
            
            // Share button could go here
        } else {
            gameOverDiv.className = 'game-over lost';
            title.textContent = 'ESCAPED!';
            
            let hint = '<div style="margin-top: 15px; color: var(--text-muted);">This puzzle was solvable in ' + gameState.perfectScore + ' guesses with perfect play.</div>';
            
            message.innerHTML = '<div style="font-size: 1.2em;">The culprit was <strong>' + gameState.culprit.name + '</strong></div>';
            message.innerHTML += '<div style="color: var(--text-secondary); margin: 10px 0;">(' + gameState.culprit.job + ')</div>';
            message.innerHTML += hint;
        }
        
        gameOverDiv.style.display = 'block';
        document.getElementById('suspectsSection').style.display = 'none';
    }

    function initGame() {
        try {
            console.log('initGame: Starting...');
            console.log('Current theme:', gameState.currentTheme);
            
            // Reset game state
            gameState.culprit = null;
            gameState.initialSuspect = null;
            gameState.suspects = [];
            gameState.guesses = [];
            gameState.currentGuess = 0;
            gameState.gameOver = false;
            gameState.won = false;
            gameState.eliminatedSuspects = new Set();
            
            // Ensure theme is set
            if (!gameState.currentTheme) {
                console.log('Theme not set in initGame, setting now');
                gameState.currentTheme = getCurrentTheme();
            }
            
            const theme = gameState.currentTheme;
            console.log('Using theme:', theme.name);
            
            // Generate suspects
            console.log('Generating suspects...');
            gameState.suspects = generateSuspects();
            console.log('Suspects generated:', gameState.suspects.length);
            console.log('Culprit:', gameState.culprit);
            console.log('Initial suspect:', gameState.initialSuspect);
            
            if (!gameState.culprit) {
                throw new Error('Culprit was not set during suspect generation');
            }
            if (!gameState.initialSuspect) {
                throw new Error('Initial suspect was not set during generation');
            }
            
            const viableSuspects = countViableSuspects();
            gameState.perfectScore = Math.ceil(Math.log2(viableSuspects)) || 3;
            gameState.optimalScore = gameState.perfectScore + 1;
            
            console.log('Setting crime details...');
            document.getElementById('crimeTitle').textContent = theme.crime.title;
            document.getElementById('crimeDescription').textContent = theme.crime.description;
            document.getElementById('viableDisplay').textContent = viableSuspects;
            
            console.log('Displaying initial suspect...');
            displayInitialSuspect();
            console.log('Displaying suspects grid...');
            displaySuspects();
            console.log('Updating guess counter...');
            updateGuessCounter();
            console.log('Starting timer...');
            startTimer();
            
            console.log('Game initialization complete');
        } catch (error) {
            console.error('Error in initGame:', error);
            console.error('Stack trace:', error.stack);
            alert('Error initializing game: ' + error.message);
        }
    }
    
    function countViableSuspects() {
        const theme = gameState.currentTheme;
        const initialFeedback = {};
        
        Object.keys(theme.traits).forEach(trait => {
            if (gameState.initialSuspect[trait] !== undefined && gameState.culprit[trait] !== undefined) {
                initialFeedback[trait] = getFeedback(gameState.initialSuspect[trait], gameState.culprit[trait], trait);
            }
        });
        
        let viableCount = 0;
        gameState.suspects.forEach(suspect => {
            let canBeValid = true;
            
            Object.keys(theme.traits).forEach(trait => {
                const initialValue = gameState.initialSuspect[trait];
                const suspectValue = suspect[trait];
                
                if (initialValue === undefined || suspectValue === undefined) return;
                
                const feedback = initialFeedback[trait];
                const arr = theme.traits[trait];
                const initialPos = arr.indexOf(initialValue);
                const suspectPos = arr.indexOf(suspectValue);
                const distance = Math.abs(initialPos - suspectPos);
                
                if (feedback === 'correct' && suspectValue !== initialValue) {
                    canBeValid = false;
                } else if (feedback === 'close' && distance !== 1) {
                    canBeValid = false;
                } else if (feedback === 'wrong' && distance < 2) {
                    canBeValid = false;
                }
            });
            
            if (canBeValid) viableCount++;
        });
        
        return viableCount || 8;
    }

    // Developer functions
    window.runAIAnalysis = function() {
        const btn = event.target;
        btn.disabled = true;
        btn.textContent = 'Running...';
        const resultsDiv = document.getElementById('aiResults');
        resultsDiv.textContent = 'Running AI analysis on current theme...\n';
        
        setTimeout(function() {
            const results = runAISimulation(200);
            let output = 'AI ANALYSIS RESULTS (' + results.totalGames + ' games)\n';
            output += '========================================\n\n';
            output += 'Theme: ' + gameState.currentTheme.name + '\n';
            output += 'Average guesses to solve: ' + results.avgGuesses.toFixed(2) + '\n';
            output += 'Win rate: ' + results.winRate + '%\n';
            output += 'Perfect play rate: ' + results.perfectRate + '%\n';
            output += 'Average viable suspects: ' + results.avgViableSuspects.toFixed(1) + '\n\n';
            output += 'ASSESSMENT:\n';
            if (results.avgGuesses >= 3.0 && results.avgGuesses <= 4.0) {
                output += '✓ WELL CALIBRATED: ' + results.avgGuesses.toFixed(2) + ' avg guesses!\n';
                output += '  Target range: 3.0-4.0 guesses\n';
            } else {
                output += '✗ Needs adjustment: ' + results.avgGuesses.toFixed(2) + ' avg guesses\n';
                output += '  Target range: 3.0-4.0 guesses\n';
            }
            
            resultsDiv.textContent = output;
            btn.disabled = false;
            btn.textContent = 'Run AI Analysis (200 games)';
        }, 100);
    };
    
    window.runQuickTest = function() {
        const btn = event.target;
        btn.disabled = true;
        btn.textContent = 'Running...';
        const resultsDiv = document.getElementById('aiResults');
        
        const results = runAISimulation(20);
        let output = 'QUICK TEST (' + results.totalGames + ' games)\n';
        output += 'Theme: ' + gameState.currentTheme.name + '\n';
        output += 'Average guesses: ' + results.avgGuesses.toFixed(2) + '\n';
        output += 'Win rate: ' + results.winRate + '%\n';
        output += 'Viable suspects: ' + results.avgViableSuspects.toFixed(1) + '\n';
        
        resultsDiv.textContent = output;
        btn.disabled = false;
        btn.textContent = 'Quick Test (20 games)';
    };
    
    window.showCulprit = function() {
        const culprit = gameState.culprit;
        const theme = gameState.currentTheme;
        if (culprit) {
            const resultsDiv = document.getElementById('aiResults');
            let output = 'CURRENT CULPRIT:\n';
            output += 'Name: ' + culprit.name + '\n';
            output += 'Job: ' + culprit.job + '\n';
            output += '==============================\n';
            Object.keys(theme.categories).forEach(trait => {
                output += theme.categories[trait] + ': ' + culprit[trait] + '\n';
            });
            resultsDiv.textContent = output;
        }
    };
    
    window.forceNewTheme = function() {
        const themeKeys = Object.keys(THEMES);
        const currentIndex = themeKeys.indexOf(Object.keys(THEMES).find(key => THEMES[key] === gameState.currentTheme));
        const nextIndex = (currentIndex + 1) % themeKeys.length;
        const newTheme = THEMES[themeKeys[nextIndex]];
        applyTheme(newTheme);
        document.getElementById('aiResults').textContent = 'Forced theme change to: ' + newTheme.name;
    };
    
    function runAISimulation(numGames) {
        let totalGuesses = 0;
        let wins = 0;
        let perfectGames = 0;
        let viableSuspectsTotal = 0;
        
        for (let i = 0; i < numGames; i++) {
            const savedDifficulty = gameState.difficulty;
            const savedTheme = gameState.currentTheme;
            
            gameState.suspects = [];
            gameState.culprit = null;
            gameState.initialSuspect = null;
            
            const suspects = generateSuspects();
            const culprit = gameState.culprit;
            const initial = gameState.initialSuspect;
            
            gameState.difficulty = savedDifficulty;
            gameState.currentTheme = savedTheme;
            
            let viableCount = 0;
            const initialFeedback = {};
            Object.keys(savedTheme.traits).forEach(trait => {
                if (initial[trait] !== undefined && culprit[trait] !== undefined) {
                    initialFeedback[trait] = getFeedback(initial[trait], culprit[trait], trait);
                }
            });
            
            suspects.forEach(suspect => {
                let canBeValid = true;
                Object.keys(savedTheme.traits).forEach(trait => {
                    if (suspect[trait] !== undefined && initial[trait] !== undefined) {
                        const arr = savedTheme.traits[trait];
                        const initialPos = arr.indexOf(initial[trait]);
                        const suspectPos = arr.indexOf(suspect[trait]);
                        const distance = Math.abs(initialPos - suspectPos);
                        
                        const feedback = initialFeedback[trait];
                        if (feedback === 'correct' && suspect[trait] !== initial[trait]) {
                            canBeValid = false;
                        } else if (feedback === 'close' && distance !== 1) {
                            canBeValid = false;
                        } else if (feedback === 'wrong' && distance < 2) {
                            canBeValid = false;
                        }
                    }
                });
                if (canBeValid) viableCount++;
            });
            
            viableSuspectsTotal += viableCount;
            const perfectScore = Math.ceil(Math.log2(viableCount));
            
            const guesses = [];
            let found = false;
            const maxGuesses = CONFIG.DIFFICULTY_SETTINGS[gameState.difficulty].maxGuesses;
            
            while (guesses.length < maxGuesses && !found) {
                const remaining = suspects.filter(s => !guesses.some(g => g.name === s.name));
                if (remaining.length === 0) break;
                
                let best = null;
                
                if (guesses.length === 0) {
                    // First guess: find suspect that best matches initial pattern
                    remaining.forEach(suspect => {
                        let canBeValid = true;
                        
                        Object.keys(savedTheme.traits).forEach(trait => {
                            if (initial[trait] !== undefined && suspect[trait] !== undefined) {
                                const feedback = initialFeedback[trait];
                                const arr = savedTheme.traits[trait];
                                const initialPos = arr.indexOf(initial[trait]);
                                const suspectPos = arr.indexOf(suspect[trait]);
                                const distance = Math.abs(initialPos - suspectPos);
                                
                                if (feedback === 'correct' && suspect[trait] !== initial[trait]) {
                                    canBeValid = false;
                                } else if (feedback === 'close' && distance !== 1) {
                                    canBeValid = false;
                                } else if (feedback === 'wrong' && distance < 2) {
                                    canBeValid = false;
                                }
                            }
                        });
                        
                        if (canBeValid && !best) {
                            best = suspect;
                        }
                    });
                } else {
                    // Use previous feedback to eliminate
                    remaining.forEach(suspect => {
                        let canBeValid = true;
                        
                        // Check against all constraints
                        guesses.forEach(previousGuess => {
                            Object.keys(savedTheme.traits).forEach(trait => {
                                if (previousGuess[trait] !== undefined && suspect[trait] !== undefined) {
                                    const previousFeedback = getFeedback(previousGuess[trait], culprit[trait], trait);
                                    const feedbackIfSuspect = getFeedback(previousGuess[trait], suspect[trait], trait);
                                    
                                    if (previousFeedback !== feedbackIfSuspect) {
                                        canBeValid = false;
                                    }
                                }
                            });
                        });
                        
                        if (canBeValid && !best) {
                            best = suspect;
                        }
                    });
                }
                
                if (best) {
                    guesses.push(best);
                    if (best.name === culprit.name) {
                        found = true;
                        wins++;
                        if (guesses.length <= perfectScore) {
                            perfectGames++;
                        }
                    }
                }
            }
            
            totalGuesses += guesses.length;
        }
        
        return {
            totalGames: numGames,
            avgGuesses: totalGuesses / numGames,
            winRate: Math.round(wins / numGames * 100),
            perfectRate: Math.round(perfectGames / numGames * 100),
            avgViableSuspects: viableSuspectsTotal / numGames
        };
    }

    // Keyboard shortcut
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'D') {
            const devTools = document.getElementById('devTools');
            devTools.style.display = devTools.style.display === 'none' ? 'block' : 'none';
        }
    });

    // Initialize on DOM load
    document.addEventListener('DOMContentLoaded', function() {
        // Set up theme
        const theme = getCurrentTheme();
        applyTheme(theme);
        gameState.puzzleNumber = getPuzzleNumber();
        
        // Start countdown timer
        updateCountdown();
        setInterval(updateCountdown, 1000);
        
        document.getElementById('start-game').addEventListener('click', function() {
            try {
                console.log('Start button clicked');
                gameState.difficulty = document.getElementById('difficulty-select').value;
                console.log('Difficulty set to:', gameState.difficulty);
                
                // Ensure theme is set
                if (!gameState.currentTheme) {
                    console.log('No theme set, applying theme');
                    applyTheme(getCurrentTheme());
                }
                
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game-screen').style.display = 'block';
                console.log('Starting game initialization...');
                initGame();
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
            }
        });
    });
})();
    </script>
</body>
</html>
                    suspect[trait] = randomValue(theme.traits[trait]);
                });
                
                suspects.push(suspect);
            }
            
            // Select a random culprit
            const culpritIndex = Math.floor(Math.random() * suspects.length);
            const culprit = suspects[culpritIndex];
            
            // Generate initial suspect
            const initialSuspect = generateInitialSuspect(culprit);
            
            // Count viable suspects
            let viableCount = 0;
            const initialFeedback = {};
            Object.keys(theme.traits).forEach(trait => {
                if (initialSuspect[trait] !== undefined) {
                    initialFeedback[trait] = getFeedback(initialSuspect[trait], culprit[trait], trait);
                }
            });
            
            suspects.forEach(suspect => {
                let canBeValid = true;
                
                Object.keys(theme.traits).forEach(trait => {
                    const initialValue = initialSuspect[trait];
                    const suspectValue = suspect[trait];
                    
                    if (initialValue === undefined) return;
                    
                    const feedback = initialFeedback[trait];
                    
                    if (suspectValue !== undefined) {
                        const arr = theme.traits[trait];
                        const initialPos = arr.indexOf(initialValue);
                        const suspectPos = arr.indexOf(suspectValue);
                        const distance = Math.abs(initialPos - suspectPos);
                        
                        if (feedback === 'correct' && suspectValue !== initialValue) {
                            canBeValid = false;
                        } else if (feedback === 'close' && distance !== 1) {
                            canBeValid = false;
                        } else if (feedback === 'wrong' && distance < 2) {
                            canBeValid = false;
                        }
                    }
                });
                
                if (canBeValid) viableCount++;
            });
            
            if (!bestSetup || (viableCount >= minViable && viableCount > bestViableCount)) {
                bestSetup = {
                    suspects: suspects,
                    culprit: culprit,
                    initialSuspect: initialSuspect,
                    viableCount: viableCount
                };
                bestViableCount = viableCount;
                
                if (viableCount >= minViable && viableCount <= minViable + 6) break;
            }
        }
        
        if (bestSetup) {
            gameState.suspects = bestSetup.suspects;
            gameState.culprit = bestSetup.culprit;
            gameState.initialSuspect = bestSetup.initialSuspect;
            
            // Add missing information to non-culprit suspects
            gameState.suspects.forEach(suspect => {
                if (suspect !== gameState.culprit) {
                    Object.keys(theme.traits).forEach(trait => {
                        if (Math.random() < missingRate) {
                            suspect[trait] = undefined;
                        }
                    });
                }
            });
        }
        
        return gameState.suspects;
    }

    function generateInitialSuspect(culprit) {
        const theme = gameState.currentTheme;
        const initial = { name: "Initial Suspect", job: "Unknown" };
        const traits = Object.keys(theme.traits);
        const settings = CONFIG.DIFFICULTY_SETTINGS[gameState.difficulty];
        const yellowCount = settings.yellowTraits;
        const grayCount = settings.grayTraits;
        const missingCount = settings.missingTraitsInitial || 0;
        
        const shuffledTraits = [...traits].sort(() => Math.random() - 0.5);
        const yellowTraits = shuffledTraits.slice(0, yellowCount);
        const grayTraits = shuffledTraits.slice(yellowCount, yellowCount + grayCount);
        const missingTraits = shuffledTraits.slice(yellowCount + grayCount, yellowCount + grayCount + missingCount);
        
        traits.forEach(trait => {
            if (missingTraits.includes(trait)) {
                initial[trait] = undefined;
            } else {
                const culpritValue = culprit[trait];
                const arr = theme.traits[trait];
                const culpritPos = arr.indexOf(culpritValue);
                
                if (yellowTraits.includes(trait)) {
                    let adjacentPos;
                    if (culpritPos === 0) {
                        adjacentPos = 1;
                    } else if (culpritPos === arr.length - 1) {
                        adjacentPos = arr.length - 2;
                    } else {
                        adjacentPos = Math.random() < 0.5 ? culpritPos - 1 : culpritPos + 1;
                    }
                    initial[trait] = arr[adjacentPos];
                } else if (grayTraits.includes(trait)) {
                    const validPositions = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (Math.abs(i - culpritPos) >= 2) {
                            validPositions.push(i);
                        }
                    }
                    if (validPositions.length > 0) {
                        const grayPos = validPositions[Math.floor(Math.random() * validPositions.length)];
                        initial[trait] = arr[grayPos];
                    } else {
                        initial[trait] = arr[0] === culpritValue ? arr[arr.length - 1] : arr[0];
                    }
                }
            }
        });
        
        return initial;
    }

    function startTimer() {
        gameState.startTime = Date.now();
        gameState.timerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timerDisplay').textContent = 
                minutes + ':' + seconds.toString().padStart(2, '0');
        }, 1000);
    }

    function stopTimer() {
        if (gameState.timerInterval) {
            clearInterval(gameState.timerInterval);
            gameState.timerInterval = null;
        }
    }

    function displayInitialSuspect() {
        const theme = gameState.currentTheme;
        const container = document.createElement('div');
        container.className = 'initial-suspect-section';
        
        let html = '<h3>Initial Suspect Profile</h3>';
        html += '<p>This person is NOT guilty. Find who shares these patterns:</p>';
        html += '<div class="initial-suspect-traits">';
        
        Object.keys(theme.traits).forEach(trait => {
            